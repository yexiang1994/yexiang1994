---
title: java基础知识
tags: [java基础知识]
---

## 位运算符
java种的运算符有 “&”,“|”,“~”,“^”即 “与”、“非”、“或”、“异或”

这几种运算符都需要将判断的字符转换成2进制，
### & 且运算符
两个操作数中位数都为1，结果才为1，否则为0
如 int a = 9;
int b = 10;
9的二进制是1001，10是1010，&的结果是1000 即8

### | 或运算符
两个位数只要一个为1，结果就是1，否则为0
如 int a = 9;
int b = 10;
9的二进制是1001，10是1010，|的结果是1011 即11

### ~ 非运算符
如果位数为0，结果是1，如果位数为1，结果是0
如 int a = 9;
9的二进制是1001，~的结果是0110 即6

### ^ 异或运算符
相对应的位 相同则结果为0，不同则结果为1
如 int a = 9;
int b = 10;
9的二进制是1001，10是1010，^的结果是0011 即3

### << 按位左移运算符
左操作数按位左移右操作数指定的位数。
如 20 << 2 
20的二进制补码：0001 0100

### >> 按位右移运算符
左操作数按位右移右操作数指定的位数。

## 一些基础概念

### 机器数
一个数在计算机中的二进制表示形式，叫做这个数的机器数，机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1
如 1的二进制数计算机字长位8位，二进制就是 0000 0001 ， -1就是 1000 0001
### 真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 1000 0001，其最高位1代表负，其真正数值是 -1 而不是形式值129（1000 0001转换成十进制等于129）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
所以 0000 0001 的真值为 +000 0001 即 1
    1000 0001 的真值为 -000 0001 即 -1

### 原码 
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
1的原码 0000 0001
-1的原码 1000 0001
8位二进制的取值范围则是[1111 1111, 0111 1111] 即 [-127, 127]

### 反码
反码就是将原码除符号位以外的值全部取反，原来是1的变为0，原来是0的变为1
正数的反码是其本身
如1的原码是： 0000 0001
反码是：      0000 0001

如-1的原码是： 1000 0001
反码是：      1111 1110

### 补码
补码就是在反码的基础上，在二进制数的右端末位加1(逢2进1)
正数的补码就是其本身
如1的原码是： 0000 0001
反码是：      0111 1110
补码是：      0000 0001

如-1的原码是： 1000 0001
反码是：      1111 1110
补码是：      1111 1111

[参考连接](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

### 移位运算
#### 左移
数值的补码全部往左移动X位，符号位和最高位都舍弃，最低位补0
如 int a = 6;
int b = a << 2;
6的补码： [0000 0000 0000 0000 0000 0000 0000 0110] 
结果：    [0000 0000 0000 0000 0000 0000 0001 1000] 即24

int a = -6;
int b = a << -6
-6的原码： [1000 0000 0000 0000 0000 0000 0000 0110]
-6的反码： [1111 1111 1111 1111 1111 1111 1111 1001]
-6的补码： [1111 1111 1111 1111 1111 1111 1111 1010]
-6的左移动2位： [1111 1111 1111 1111 1111 1111 1110 1000]
然后将补码转成原码： 先补码的反码再加1
即 [1000 0000 0000 0000 0000 0000 0001 0111] =》 [1000 0000 0000 0000 0000 0000 0001 1000] 
结果为 -24
左移n位就相当于乘以2的n次方

#### 右移
数值的补码向右移X位，符号位不变（左边补上符号位） 
int a=8
int b=a>> 2
8的原码 [0000 0000 0000 0000 0000 0000 0000 1000]
8向右移动两位 [0000 0000 0000 0000 0000 0000 0000 0010]
结果为 2

int a=-8
int b=a>> 2
-8的原码 [0000 0000 0000 0000 0000 0000 0000 1000]
-8的反码 [1111 1111 1111 1111 1111 1111 1111 0111]
-8的补码 [1111 1111 1111 1111 1111 1111 1111 1000]
-8向右移动两位 [1111 1111 1111 1111 1111 1111 1111 1110]
然后取补码的反码 [1000 0000 0000 0000 0000 0000 0000 0001]
补码的原码 [1000 0000 0000 0000 0000 0000 0000 0010]
结果为 -2

